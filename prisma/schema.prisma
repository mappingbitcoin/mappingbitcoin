// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// Venues table - exists only for FK integrity
// No venue data stored here â€” that's in memory
model Venue {
  id        String   @id @default(cuid())
  osmId     String   @unique @map("osm_id")
  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  claims  Claim[]
  reviews Review[]

  @@index([osmId])
  @@map("venues")
}

// Users table - Nostr users with cached profile data
model User {
  id               String    @id @default(cuid())
  pubkey           String    @unique
  name             String?   // cached from kind 0
  picture          String?   // cached from kind 0
  nip05            String?
  profileUpdatedAt DateTime? @map("profile_updated_at")
  createdAt        DateTime  @default(now()) @map("created_at")

  // Relations
  claims        Claim[]
  reviews       Review[]
  reviewReplies ReviewReply[]

  @@index([pubkey])
  @@map("users")
}

// Claims table - venue ownership claims
model Claim {
  id                   String      @id @default(cuid())
  venueId              String      @map("venue_id")
  claimerPubkey        String      @map("claimer_pubkey")
  status               ClaimStatus @default(PENDING)
  method               ClaimMethod
  verificationCode     String?     @map("verification_code")
  verificationAttempts Int         @default(0) @map("verification_attempts")
  verifiedAt           DateTime?   @map("verified_at")
  expiresAt            DateTime?   @map("expires_at")
  createdAt            DateTime    @default(now()) @map("created_at")
  verifiedEmailHash    String?     @map("verified_email_hash") // SHA-256 hash of verified email
  revokedAt            DateTime?   @map("revoked_at")
  revokedReason        String?     @map("revoked_reason") // e.g., "email_changed"

  // Domain verification fields
  domainToVerify       String?     @map("domain_to_verify") // e.g., "example.com"
  txtRecordValue       String?     @map("txt_record_value") // e.g., "mappingbitcoin-verify=abc123"
  lastCheckAt          DateTime?   @map("last_check_at") // Last manual check timestamp
  nextCheckAt          DateTime?   @map("next_check_at") // When next check is allowed (rate limiting)
  checkCount           Int         @default(0) @map("check_count") // Number of checks performed

  // Relations
  venue   Venue @relation(fields: [venueId], references: [id], onDelete: Cascade)
  claimer User  @relation(fields: [claimerPubkey], references: [pubkey], onDelete: Cascade)

  @@index([venueId])
  @@index([claimerPubkey])
  @@index([status])
  @@map("claims")
}

// Auth challenges for Nostr authentication
model AuthChallenge {
  id        String    @id @default(cuid())
  pubkey    String
  challenge String    @unique
  expiresAt DateTime  @map("expires_at")
  usedAt    DateTime? @map("used_at")
  createdAt DateTime  @default(now()) @map("created_at")

  @@index([pubkey])
  @@map("auth_challenges")
}

enum ClaimStatus {
  PENDING  @map("pending")
  VERIFIED @map("verified")
  REJECTED @map("rejected")
  EXPIRED  @map("expired")
}

enum ClaimMethod {
  PHONE    @map("phone")
  EMAIL    @map("email")
  DOMAIN   @map("domain")
  GOOGLE   @map("google")
  PHYSICAL @map("physical")
  MANUAL   @map("manual")
}

// Reviews table - venue reviews from Nostr
model Review {
  id             String   @id @default(cuid())
  eventId        String   @unique @map("event_id")
  venueId        String   @map("venue_id")
  authorPubkey   String   @map("author_pubkey")
  rating         Int?     // 1-5 stars, nullable for text-only reviews
  content        String?
  eventCreatedAt DateTime @map("event_created_at")
  indexedAt      DateTime @default(now()) @map("indexed_at")

  // Relations
  venue   Venue         @relation(fields: [venueId], references: [id], onDelete: Cascade)
  author  User          @relation(fields: [authorPubkey], references: [pubkey], onDelete: Cascade)
  replies ReviewReply[]

  @@index([venueId])
  @@index([authorPubkey])
  @@index([eventCreatedAt])
  @@map("reviews")
}

// Review replies table
model ReviewReply {
  id             String   @id @default(cuid())
  eventId        String   @unique @map("event_id")
  reviewId       String   @map("review_id")
  authorPubkey   String   @map("author_pubkey")
  content        String
  isOwnerReply   Boolean  @default(false) @map("is_owner_reply")
  eventCreatedAt DateTime @map("event_created_at")
  indexedAt      DateTime @default(now()) @map("indexed_at")

  // Relations
  review Review @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  author User   @relation(fields: [authorPubkey], references: [pubkey], onDelete: Cascade)

  @@index([reviewId])
  @@index([authorPubkey])
  @@map("review_replies")
}

// ============================================
// Newsletter Subscription System
// ============================================

// Subscription lists (e.g., newsletter, updates, announcements)
model SubscriptionList {
  id          String   @id @default(cuid())
  slug        String   @unique // e.g., "newsletter", "updates"
  name        String   // Display name
  description String?
  createdAt   DateTime @default(now()) @map("created_at")

  // Relations
  subscribers SubscriberList[]

  @@map("subscription_lists")
}

// Email subscribers
model Subscriber {
  id               String    @id @default(cuid())
  email            String    @unique
  unsubscribeToken String    @unique @map("unsubscribe_token")
  confirmedAt      DateTime? @map("confirmed_at")
  createdAt        DateTime  @default(now()) @map("created_at")

  // Relations
  lists SubscriberList[]

  @@index([email])
  @@index([unsubscribeToken])
  @@map("subscribers")
}

// Many-to-many relation: subscribers to lists
model SubscriberList {
  id             String   @id @default(cuid())
  subscriberId   String   @map("subscriber_id")
  listId         String   @map("list_id")
  subscribedAt   DateTime @default(now()) @map("subscribed_at")
  unsubscribedAt DateTime? @map("unsubscribed_at")

  // Relations
  subscriber Subscriber       @relation(fields: [subscriberId], references: [id], onDelete: Cascade)
  list       SubscriptionList @relation(fields: [listId], references: [id], onDelete: Cascade)

  @@unique([subscriberId, listId])
  @@index([subscriberId])
  @@index([listId])
  @@map("subscriber_lists")
}
