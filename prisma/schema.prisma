// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// Venues table - exists only for FK integrity
// No venue data stored here â€” that's in memory
model Venue {
  id        String   @id @default(cuid())
  osmId     String   @unique @map("osm_id")
  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  claims  Claim[]
  reviews Review[]

  @@index([osmId])
  @@map("venues")
}

// Users table - Nostr users with cached profile data
model User {
  id               String    @id @default(cuid())
  pubkey           String    @unique
  name             String?   // cached from kind 0
  picture          String?   // cached from kind 0
  nip05            String?
  profileUpdatedAt DateTime? @map("profile_updated_at")
  createdAt        DateTime  @default(now()) @map("created_at")

  // Relations
  claims        Claim[]
  reviews       Review[]
  reviewReplies ReviewReply[]

  @@index([pubkey])
  @@map("users")
}

// Claims table - venue ownership claims
model Claim {
  id                   String      @id @default(cuid())
  venueId              String      @map("venue_id")
  claimerPubkey        String      @map("claimer_pubkey")
  status               ClaimStatus @default(PENDING)
  method               ClaimMethod
  verificationCode     String?     @map("verification_code")
  verificationAttempts Int         @default(0) @map("verification_attempts")
  verifiedAt           DateTime?   @map("verified_at")
  expiresAt            DateTime?   @map("expires_at")
  createdAt            DateTime    @default(now()) @map("created_at")
  verifiedEmailHash    String?     @map("verified_email_hash") // SHA-256 hash of verified email
  revokedAt            DateTime?   @map("revoked_at")
  revokedReason        String?     @map("revoked_reason") // e.g., "email_changed"

  // Domain verification fields
  domainToVerify       String?     @map("domain_to_verify") // e.g., "example.com"
  txtRecordValue       String?     @map("txt_record_value") // e.g., "mappingbitcoin-verify=abc123"
  lastCheckAt          DateTime?   @map("last_check_at") // Last manual check timestamp
  nextCheckAt          DateTime?   @map("next_check_at") // When next check is allowed (rate limiting)
  checkCount           Int         @default(0) @map("check_count") // Number of checks performed

  // Relations
  venue   Venue @relation(fields: [venueId], references: [id], onDelete: Cascade)
  claimer User  @relation(fields: [claimerPubkey], references: [pubkey], onDelete: Cascade)

  @@index([venueId])
  @@index([claimerPubkey])
  @@index([status])
  @@map("claims")
}

// Auth challenges for Nostr authentication
model AuthChallenge {
  id        String    @id @default(cuid())
  pubkey    String
  challenge String    @unique
  expiresAt DateTime  @map("expires_at")
  usedAt    DateTime? @map("used_at")
  createdAt DateTime  @default(now()) @map("created_at")

  @@index([pubkey])
  @@map("auth_challenges")
}

enum ClaimStatus {
  PENDING  @map("pending")
  VERIFIED @map("verified")
  REJECTED @map("rejected")
  EXPIRED  @map("expired")
}

enum ClaimMethod {
  PHONE    @map("phone")
  EMAIL    @map("email")
  DOMAIN   @map("domain")
  GOOGLE   @map("google")
  PHYSICAL @map("physical")
  MANUAL   @map("manual")
}

// Reviews table - venue reviews from Nostr
model Review {
  id             String   @id @default(cuid())
  eventId        String   @unique @map("event_id")
  venueId        String   @map("venue_id")
  authorPubkey   String   @map("author_pubkey")
  rating         Int?     // 1-5 stars, nullable for text-only reviews
  content        String?
  eventCreatedAt DateTime @map("event_created_at")
  indexedAt      DateTime @default(now()) @map("indexed_at")

  // Spam filtering
  spamScore      Float?       @map("spam_score")      // 0-1, higher = more likely spam
  spamStatus     SpamStatus   @default(PENDING) @map("spam_status")
  spamReasons    String[]     @map("spam_reasons")    // Array of reasons if flagged

  // Relations
  venue   Venue         @relation(fields: [venueId], references: [id], onDelete: Cascade)
  author  User          @relation(fields: [authorPubkey], references: [pubkey], onDelete: Cascade)
  replies ReviewReply[]

  @@index([venueId])
  @@index([authorPubkey])
  @@index([eventCreatedAt])
  @@index([spamStatus])
  @@map("reviews")
}

// Spam status for reviews
enum SpamStatus {
  PENDING   @map("pending")    // Awaiting moderation
  APPROVED  @map("approved")   // Manually or auto-approved
  FLAGGED   @map("flagged")    // Flagged for review
  BLOCKED   @map("blocked")    // Blocked as spam
}

// Review replies table
model ReviewReply {
  id             String   @id @default(cuid())
  eventId        String   @unique @map("event_id")
  reviewId       String   @map("review_id")
  authorPubkey   String   @map("author_pubkey")
  content        String
  isOwnerReply   Boolean  @default(false) @map("is_owner_reply")
  eventCreatedAt DateTime @map("event_created_at")
  indexedAt      DateTime @default(now()) @map("indexed_at")

  // Relations
  review Review @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  author User   @relation(fields: [authorPubkey], references: [pubkey], onDelete: Cascade)

  @@index([reviewId])
  @@index([authorPubkey])
  @@map("review_replies")
}

// ============================================
// Newsletter Subscription System
// ============================================

// Subscription lists (e.g., newsletter, updates, announcements)
model SubscriptionList {
  id          String   @id @default(cuid())
  slug        String   @unique // e.g., "newsletter", "updates"
  name        String   // Display name
  description String?
  createdAt   DateTime @default(now()) @map("created_at")

  // Relations
  subscribers SubscriberList[]

  @@map("subscription_lists")
}

// Email subscribers
model Subscriber {
  id               String    @id @default(cuid())
  email            String    @unique
  unsubscribeToken String    @unique @map("unsubscribe_token")
  confirmedAt      DateTime? @map("confirmed_at")
  createdAt        DateTime  @default(now()) @map("created_at")

  // Relations
  lists SubscriberList[]

  @@index([email])
  @@index([unsubscribeToken])
  @@map("subscribers")
}

// Many-to-many relation: subscribers to lists
model SubscriberList {
  id             String    @id @default(cuid())
  subscriberId   String    @map("subscriber_id")
  listId         String    @map("list_id")
  subscribedAt   DateTime  @default(now()) @map("subscribed_at")
  unsubscribedAt DateTime? @map("unsubscribed_at")

  // Relations
  subscriber Subscriber       @relation(fields: [subscriberId], references: [id], onDelete: Cascade)
  list       SubscriptionList @relation(fields: [listId], references: [id], onDelete: Cascade)

  @@unique([subscriberId, listId])
  @@index([subscriberId])
  @@index([listId])
  @@map("subscriber_lists")
}

// ============================================
// Community Trust System
// ============================================

// Admin users who can manage seeders and system settings
model AdminUser {
  id        String   @id @default(cuid())
  pubkey    String   @unique
  label     String?
  createdAt DateTime @default(now()) @map("created_at")

  @@map("admin_users")
}

// Community seeders - trusted nodes in the social graph
model CommunitySeeder {
  id        String   @id @default(cuid())
  pubkey    String   @unique
  region    String
  label     String?
  addedBy   String?  @map("added_by")
  createdAt DateTime @default(now()) @map("created_at")

  @@map("community_seeders")
}

// Pre-computed trust graph nodes with follower counts by depth
model CommunityGraph {
  id               String   @id @default(cuid())
  pubkey           String   @unique

  // Is this pubkey a seeder themselves?
  isSeeder         Boolean  @default(false) @map("is_seeder")

  // Follower counts: how many people at each depth follow this user
  followedByDepth0 Int      @default(0) @map("followed_by_depth_0")  // Seeders who follow this user
  followedByDepth1 Int      @default(0) @map("followed_by_depth_1")  // Depth-1 users who follow this user
  followedByDepth2 Int      @default(0) @map("followed_by_depth_2")  // Depth-2 users who follow this user

  // Total followers in the trust network
  totalTrustFollowers Int   @default(0) @map("total_trust_followers")

  // Minimum depth at which this user appears (0=seeder, 1=followed by seeder, etc)
  minDepth         Int      @map("min_depth")

  // Calculated trust score (can be recomputed from counts)
  score            Float

  computedAt       DateTime @default(now()) @map("computed_at")

  @@index([score(sort: Desc)])
  @@index([minDepth])
  @@index([followedByDepth0(sort: Desc)])
  @@map("community_graph")
}

// Cache for Nostr follows (kind 3 events)
model FollowsCache {
  id            String   @id @default(cuid())
  pubkey        String
  followsPubkey String   @map("follows_pubkey")
  fetchedAt     DateTime @default(now()) @map("fetched_at")

  @@unique([pubkey, followsPubkey])
  @@index([pubkey])
  @@map("follows_cache")
}

// Log of graph build operations
model GraphBuildLog {
  id           String           @id @default(cuid())
  startedAt    DateTime         @default(now()) @map("started_at")
  completedAt  DateTime?        @map("completed_at")
  status       GraphBuildStatus
  seedersCount Int?             @map("seeders_count")
  nodesCount   Int?             @map("nodes_count")
  errorMessage String?          @map("error_message")

  @@map("graph_build_logs")
}

enum GraphBuildStatus {
  RUNNING   @map("running")
  COMPLETED @map("completed")
  FAILED    @map("failed")
}
